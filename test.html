<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  <title>New Hasql: Faster and Simpler</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="progress-bar"></div>
    <div class="slide" id="slide-1">
    <section class="slide-content">
      <h1 id="new-hasql-faster-and-simpler">New Hasql: Faster and Simpler</h1>
<!-- 
  In this talk I'm gonna try a new thing. 

  I'll brand it a statement-driven talk. You can use this term, just don't forget to mention my name.

  Slides will be statements, and I'll providing the details.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-2">
    <section class="slide-content">
      <h1 id="me">Me</h1>
<!-- 
  I'm a nice guy. Seriously. But if you violate my trademark I'll sue the hell out of you!

  I like hanging out with friends and I dedicate myself to my passions.

  Haskell is both my friend and my passion.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-3">
    <section class="slide-content">
      <h1 id="me">Me</h1>
<ul>
<li>Author of the &quot;record&quot; library for Haskell</li>
</ul>
<!-- 
  One of the solutions to the Record Problem.

  You might have heard about it on Reddit.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-4">
    <section class="slide-content">
      <h1 id="me">Me</h1>
<ul>
<li><p>Author of the &quot;record&quot; library for Haskell</p>
</li>
<li><p>Author of SORM Framework for Scala</p>
</li>
</ul>
<!-- 
  This is an important fact.

  I no longer develop that library, but I am it's author.

  I have created an ORM library in my past. Please keep that in mind, when I start bashing on ORMs.

  Also I have worked with Scala, so. You know. Cautios!
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-5">
    <section class="slide-content">
      <h1 id="me">Me</h1>
<ul>
<li><p>Author of the &quot;record&quot; library for Haskell</p>
</li>
<li><p>Author of SORM Framework for Scala</p>
</li>
<li><p>Author of &quot;hasql&quot;</p>
</li>
</ul>
<!-- 
  And proud of that!
 -->
    </section>
  </div>
  <div class="slide hidden  " id="slide-6">
    <section class="slide-content">
      <h1 id="haskell-needs-more-people">Haskell needs more people</h1>
<!-- 
If we want our favorite language to succeed, we need to attract more people into the community. Both those who seek jobs and those who provide them.

This means that we need to learn to approach those audiences.
 -->
    </section>
  </div>
  <div class="slide hidden  " id="slide-7">
    <section class="slide-content">
      <h1 id="quality-of-algorithms-speed-of-the-language">Quality of algorithms &gt; Speed of the language</h1>
<!-- 
We've all heard that it's not as much the speed of the language's runtime as the quality of your algorithms and abstractions that affects the performance of your applications.

We tend to never take that seriously, because rarely do we see any practical examples.

C is faster than Haskell. That's a fact. But that doesn't necessarily mean that applications written in C are faster than their Haskell counterparts.

We have some examples, but the more we get the better our publicity becomes.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-8">
    <section class="slide-content">
      <h1 id="people-are-ignorant">People are ignorant</h1>
<!-- 
Haskell has beautiful polished abstractions backed by **centuries** (Not decades) of research in mathematics and a very powerful concurrency ecosystem and that all matters.

Whenever someone starts talking about such things as abstractions and theory the typical reaction is to wash it off as an academical and highly unpractical jibber-jabber. 

Just think about that: centuries of research by the smartest people on this planet, yet the other people treat that as something negligible. This looks like ignorance beyond any sensible explanation to me. But we need to get thru it.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-9">
    <section class="slide-content">
      <h1 id="people-need-practical-success-stories">People need practical success-stories</h1>
<!-- 
They say that Haskellers live in a mythical world and don't deal with real problems. And that is why we need projects, which deal with real problems.

What is more practical than the problem of database integration? Nearly every real-life application has some sort of persistence model. And Postgres lately has become a de facto default choice for SQL database.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-10">
    <section class="slide-content">
      <h1 id="hasql-will-beat-libpq-">Hasql will beat &quot;libpq&quot;</h1>
<!-- 
This is why I've set myself a goal to beat C with this project.

I have yet to claim victory on that part. But I'm working.

Hasql's C rival is called "libpq".

The native Hasql version can already perform on par with "libpq" and even beat it sometimes. 

I have reasons to believe that I can achieve even better results, which is why the work goes on.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-11">
    <section class="slide-content">
      <h1 id="releases">Releases</h1>
<!-- 
  For this talk I have prepared a sort of an MVP version of the project.

  It is experimental, it might contain bugs, and is not optimised. But it works and proves the concepts.

  To be able to release it without affecting the reputation of the library I had to come up with something.

  I've found a nice solution.
 -->
    </section>
  </div>
  <div class="slide hidden  " id="slide-12">
    <section class="slide-content">
      <h1 id="can-you-spot-a-pattern-here-">Can you spot a pattern here?</h1>
<ul>
<li>Latest version of &quot;transformers&quot; is 0.5.5.0</li>
<li>Latest version of &quot;bytestring&quot; is 0.10.8.2</li>
<li>Latest version of &quot;vector&quot; is 0.12.0.1</li>
</ul>
<!-- 
Right! The versions of all of those libraries begin with zero.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-13">
    <section class="slide-content">
      <p>What&#39;s the point in having &quot;0.x&quot;?</p>
<p>PVP has no explanation.</p>
<!-- 
Officially it is just another major version number. IOW, we have two.

People suggest to use it for marketting.

When that first number is zero, it means that the package is in an "experimental" stage.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-14">
    <section class="slide-content">
      <ul>
<li>&quot;transformers&quot;</li>
<li>&quot;bytestring&quot;</li>
<li>&quot;vector&quot;</li>
</ul>
<p>Foundational, production-ready libraries live in &quot;experimental&quot; version space.</p>
<!-- 
Look again at those names.

All of these libraries are highly stable, deeply tested and foundational for the whole ecosystem. If they can't be called production-ready, then I don't know what can. Yet these libraries are stuck in this zero-prefixed version space.

It is a problem, but it isn't what I'm gonna discuss.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-15">
    <section class="slide-content">
      <h1 id="two-rules">Two rules</h1>
<ul>
<li><p>Prefix experimental releases with 0</p>
</li>
<li><p>Prefix stable releases with numbers &gt; 0</p>
</li>
</ul>
<!-- 
You might ask: yeah, what's new about it? Just consider it in isolation. 

We've never considered using the zero-space after having made a release in the `1.x` space.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-16">
    <section class="slide-content">
      <h1 id="two-rules">Two rules</h1>
<ul>
<li><p>Prefix experimental releases with 0 - the <code>dev</code> branch</p>
</li>
<li><p>Prefix stable releases with numbers &gt; 0 - the <code>master</code> branch</p>
</li>
</ul>
<!-- 
You can easily spot a corelation with repository branches.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-17">
    <section class="slide-content">
      <h1 id="new-versions-of-hasql">New versions of Hasql</h1>
<p>The battle-tested Hasql <code>0.19</code> becomes <code>1</code>.</p>
<p>New experimental Hasql becomes <code>0.20</code>.</p>
<!-- 
Thus I get the benefits of both worlds: rapid development and stability.

I get to experiment in the `0.x` space all I want. I can allow myself to literally go nuts there!

The users will still feel safe and get delivered what they are promised.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-18">
    <section class="slide-content">
      <h1 id="what-s-wrong-with-libpq-">What&#39;s wrong with &quot;libpq&quot;?</h1>

    </section>
  </div>
  <div class="slide hidden" id="slide-19">
    <section class="slide-content">
      <h1 id="what-s-wrong-with-libpq-">What&#39;s wrong with &quot;libpq&quot;?</h1>
<ul>
<li>It caches the whole response</li>
</ul>

    </section>
  </div>
  <div class="slide hidden" id="slide-20">
    <section class="slide-content">
      <h1 id="what-s-wrong-with-libpq-">What&#39;s wrong with &quot;libpq&quot;?</h1>
<ul>
<li><p>It caches the whole response</p>
</li>
<li><p>It doesn&#39;t let you do pipelining</p>
</li>
</ul>

    </section>
  </div>
  <div class="slide hidden" id="slide-21">
    <section class="slide-content">
      <p><img src="1.svg" alt=""></p>

    </section>
  </div>
  <div class="slide hidden" id="slide-22">
    <section class="slide-content">
      <pre><code class="lang-haskell"><span class="hljs-title">personsBornAfter</span> :: <span class="hljs-type">Statement</span> <span class="hljs-type">Day</span> (<span class="hljs-type">Vector</span> (<span class="hljs-type">Text</span>, <span class="hljs-type">Day</span>))
<span class="hljs-title">personsBornAfter</span> =
  <span class="hljs-type">Statement</span>.prepared sql encodeParams decodeResult
  <span class="hljs-keyword">where</span>
    sql =
      <span class="hljs-string">"SELECT name, birthday \
        \FROM person \
        \WHERE birthday &gt; $1"</span>
    encodeParams =
      <span class="hljs-type">EncodeParams</span>.param (<span class="hljs-type">EncodeParam</span>.primitive <span class="hljs-type">EncodePrimitive</span>.date)
    decodeResult =
      <span class="hljs-type">DecodeResult</span>.foldRows <span class="hljs-type">Foldl</span>.vector decodeRow
      <span class="hljs-keyword">where</span>
        decodeRow =
          (,) &lt;$&gt; <span class="hljs-type">DecodeRow</span>.primitive <span class="hljs-type">DecodePrimitive</span>.text &lt;*&gt;
                  <span class="hljs-type">DecodeRow</span>.primitive <span class="hljs-type">DecodePrimitive</span>.date</code></pre>
<!-- 
Here's something from new Hasql:

See? A statement again!

Notice the Foldl there! It is being executed while the result is still being received!

 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-23">
    <section class="slide-content">
      <h1 id="executing">Executing</h1>
<pre><code class="lang-haskell"><span class="hljs-title">getPersonsBornAfter</span> :: <span class="hljs-type">Connection</span> -&gt; <span class="hljs-type">Day</span> -&gt; <span class="hljs-type">IO</span> (<span class="hljs-type">Vector</span> (<span class="hljs-type">Text</span>, <span class="hljs-type">Day</span>))
<span class="hljs-title">getPersonsBornAfter</span> connection after =
  <span class="hljs-type">Connection</span>.session connection $ <span class="hljs-type">Session</span>.batch $
  <span class="hljs-type">Batch</span>.statement <span class="hljs-type">Statements</span>.personsBornAfter after</code></pre>
<!-- 
This is how you execute it.

Notice a Batch abstraction layer there?
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-24">
    <section class="slide-content">
      <h1 id="batch-execution">Batch execution</h1>
<pre><code class="lang-haskell"><span class="hljs-title">getPersonsBornAfter</span> :: <span class="hljs-type">Connection</span> -&gt; [<span class="hljs-type">Day</span>] -&gt; <span class="hljs-type">IO</span> (<span class="hljs-type">Vector</span> (<span class="hljs-type">Text</span>, <span class="hljs-type">Day</span>))
<span class="hljs-title">getPersonsBornAfter</span> connection afterList =
  <span class="hljs-type">Connection</span>.session connection $ <span class="hljs-type">Session</span>.batch $
  traverse (<span class="hljs-type">Batch</span>.statement <span class="hljs-type">Statements</span>.personsBornAfter after) afterList</code></pre>
<!-- 
This is it. The pipelining!
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-25">
    <section class="slide-content">
      <h1 id="why-not-fromrow-torow-">Why not FromRow, ToRow?</h1>

    </section>
  </div>
  <div class="slide hidden" id="slide-26">
    <section class="slide-content">
      <pre><code class="lang-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Person</span> = <span class="hljs-type">Person</span> <span class="hljs-type">Text</span> <span class="hljs-type">Day</span></span>
<span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">FromRow</span> <span class="hljs-type">Person</span> <span class="hljs-keyword">where</span></span> ...

<span class="hljs-title">getPersons</span> :: <span class="hljs-type">IO</span> (<span class="hljs-type">Vector</span> <span class="hljs-type">Person</span>)
<span class="hljs-title">getPersons</span> =
  someHowExecuteQuery
    <span class="hljs-string">"SELECT name, birthday \
      \FROM person \
      \WHERE birthday &gt; $1"</span></code></pre>

    </section>
  </div>
  <div class="slide hidden" id="slide-27">
    <section class="slide-content">
      <pre><code class="lang-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Person</span> = <span class="hljs-type">Person</span> <span class="hljs-type">Text</span> <span class="hljs-type">Day</span></span>
<span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">FromRow</span> <span class="hljs-type">Person</span> <span class="hljs-keyword">where</span></span> ...

<span class="hljs-title">getPersons</span> :: <span class="hljs-type">IO</span> (<span class="hljs-type">Vector</span> <span class="hljs-type">Person</span>)
<span class="hljs-title">getPersons</span> =
  someHowExecuteQuery
    <span class="hljs-string">"SELECT name, id \
      \FROM person \
      \WHERE birthday &gt; $1"</span></code></pre>
<!-- 
See the difference?
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-28">
    <section class="slide-content">
      <pre><code class="lang-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Person</span> = <span class="hljs-type">Person</span> <span class="hljs-type">Text</span> <span class="hljs-type">Day</span></span>
<span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">FromRow</span> <span class="hljs-type">Person</span> <span class="hljs-keyword">where</span></span> ...

<span class="hljs-title">getPersons</span> :: <span class="hljs-type">IO</span> (<span class="hljs-type">Vector</span> <span class="hljs-type">Person</span>)
<span class="hljs-title">getPersons</span> =
  someHowExecuteQuery
    <span class="hljs-string">"SELECT name, birthday \
      \FROM person \
      \WHERE birthday &gt; $1"</span></code></pre>
<!-- Look again -->
    </section>
  </div>
  <div class="slide hidden" id="slide-29">
    <section class="slide-content">
      <pre><code class="lang-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Person</span> = <span class="hljs-type">Person</span> <span class="hljs-type">Text</span> <span class="hljs-type">Day</span></span>
<span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">FromRow</span> <span class="hljs-type">Person</span> <span class="hljs-keyword">where</span></span> ...

<span class="hljs-title">getPersons</span> :: <span class="hljs-type">IO</span> (<span class="hljs-type">Vector</span> <span class="hljs-type">Person</span>)
<span class="hljs-title">getPersons</span> =
  someHowExecuteQuery
    <span class="hljs-string">"SELECT name, id \
      \FROM person \
      \WHERE birthday &gt; $1"</span></code></pre>
<!--
  See?

  We've just introduced a bug, which the compiler can't spot.

  The reason is that FromRow instance defines what the statement produces,
  instead of the statement.

  It's a leaky abstraction.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-30">
    <section class="slide-content">
      <p>Why Contravariant functors for encoders?</p>
<p>Why not just Monoid?</p>
<!-- 

It actually can be Monoid, but with consequences. Let's see why.

 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-31">
    <section class="slide-content">
      <pre><code class="lang-haskell"><span class="hljs-title">parameters</span> :: <span class="hljs-type">Encode</span> (<span class="hljs-type">Text</span>, <span class="hljs-type">UTCTime</span>)
<span class="hljs-title">parameters</span> =
  contrazip2 <span class="hljs-type">Encode</span>.text <span class="hljs-type">Encode</span>.timestamptz</code></pre>
<p>vs.</p>
<pre><code class="lang-haskell"><span class="hljs-title">parameters</span> :: <span class="hljs-type">Text</span> -&gt; <span class="hljs-type">UTCTime</span> -&gt; <span class="hljs-type">Encoding</span>
<span class="hljs-title">parameters</span> name date =
  <span class="hljs-type">Encoding</span>.text name &lt;&gt; <span class="hljs-type">Encoding</span>.timestamptz date</code></pre>
<!-- 
On the one hand, a Monoidal API would be easier to deal with, since it would be around just functions.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-32">
    <section class="slide-content">
      <pre><code class="lang-haskell"><span class="hljs-title">parameters</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Encoding</span>
<span class="hljs-title">parameters</span> int =
  <span class="hljs-keyword">if</span> int &lt;= <span class="hljs-number">32767</span>
    <span class="hljs-keyword">then</span> <span class="hljs-type">Encode</span>.int2 (fromIntegral int)
    <span class="hljs-keyword">else</span> <span class="hljs-type">Encode</span>.int4 (fromIntegral int)</code></pre>
<!-- 
On the other hand it gives the user too much freedom. Letting him falsely believe that he's doing a valid thing, when he's doing something like this.

If it is possible, it shouldn't be wrong, right?

This is gonna trigger a query error in some scenarios. But with such API this bug is impossible to track down with the compiler.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-33">
    <section class="slide-content">
      <h1 id="if-an-abstraction-lets-you-do-a-wrong-thing-the-abstraction-is-wrong-">If an abstraction lets you do a wrong thing, the abstraction is wrong!</h1>
<!-- 
I believe that with all my heart and I try to live by that.

I must remind you that this library has a purpose of leading the user to do the right thing as much as possible.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-34">
    <section class="slide-content">
      <h1 id="monoidal-api-wouldn-t-have-static-metainformation">Monoidal API wouldn&#39;t have static metainformation</h1>
<!-- 
There's also another disatvantage to the Monoid-based API, which is that it doesn't let us cache the information that can be derived statically. Since it's all functions, such encoders need to be fully reevaluated for every execution of the query.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-35">
    <section class="slide-content">
      <pre><code class="lang-haskell"><span class="hljs-title">parameters</span> :: <span class="hljs-type">Encode</span> (<span class="hljs-type">Text</span>, <span class="hljs-type">UTCTime</span>)
<span class="hljs-title">parameters</span> =
  contrazip2 <span class="hljs-type">Encode</span>.text <span class="hljs-type">Encode</span>.timestamptz</code></pre>
<!-- 

In this contravariant expression we know statically that the parameters will be mapped to the TEXT and TIMESTAMPTZ Postgres types. 

We can derive that the query will have 2 parameters, as well as the associated vector of type identifiers (OIDs) to send to Postgres.

To do all that we don't need to provide any values! 
This is the contravariant API for you.

However I must admit, that at the first glance, contravariant functors are harder to wrap the head around and work with than functions producing monoids. It grows on you however, trust me.

 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-36">
    <section class="slide-content">
      <pre><code class="lang-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Encoding</span> =</span>
  <span class="hljs-keyword">forall</span> input. <span class="hljs-type">Encoding</span> (<span class="hljs-type">Encode</span> input) input
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Monoid</span> <span class="hljs-type">Encoding</span> <span class="hljs-keyword">where</span></span> ...</code></pre>
<!-- 
More so, it is even possible to introduce a Monoidal API in an Ad-hoc fashion (e.g., as an external library).

And theoretically, it shouldn't lose in performance compared to a direct implementation.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-37">
    <section class="slide-content">
      <pre><code class="lang-haskell">
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Supplied</span> divisible =</span>
  <span class="hljs-keyword">forall</span> input . <span class="hljs-type">Supplied</span> !(divisible input) !input

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Encoding</span> =</span>
  <span class="hljs-type">Supplied</span> <span class="hljs-type">Encode</span></code></pre>
<!-- 
The "contravariant-extras" package provides a general type for this.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-38">
    <section class="slide-content">
      <pre><code class="lang-haskell"><span class="hljs-title">statement</span> :: <span class="hljs-type">Statement</span> (<span class="hljs-type">Gender</span>, <span class="hljs-type">UTCTime</span>) (<span class="hljs-type">Vector</span> (<span class="hljs-type">Int64</span>, <span class="hljs-type">Text</span>))
<span class="hljs-title">statement</span> =
  [statement|
    <span class="hljs-type">SELECT</span> id, name
    <span class="hljs-type">WHERE</span> gender = $<span class="hljs-number">1</span> <span class="hljs-type">AND</span> birthday &gt;= $<span class="hljs-number">2</span>
  |]</code></pre>
<!-- 
However instead of pushing for the Monoid APIs to make things easier for the beginners, I've left that as a task for the extension libraries. And I actually plan to release one later.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-39">
    <section class="slide-content">
      <pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; :t [statement| <span class="hljs-type">SELECT</span> id, name
                     <span class="hljs-type">WHERE</span> gender = $<span class="hljs-number">1</span> <span class="hljs-type">AND</span> birthday &gt;= $<span class="hljs-number">2</span>|]

( <span class="hljs-type">DefaultRowEncoder</span> param1, <span class="hljs-type">DefaultRowEncoder</span> param2,
  <span class="hljs-type">DefaultResultDecoder</span> (column1, column2) result,
  <span class="hljs-type">DefaultColumnDecoder</span> column1,
  <span class="hljs-type">DefaultColumnDecoder</span> column2 ) =&gt;
  <span class="hljs-type">Statement</span> (param1, param2) result</code></pre>
<!-- 
Under the hood I plan for the quasiquoter to actually generate something in the spirit of this function.

However you can see that this approach heavily relies on custom typeclasses, which I've already kind of bashed upon even during this talk. So this is all, let's say... under consideration.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-40">
    <section class="slide-content">
      <pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; :t [statement| <span class="hljs-type">SELECT</span> id :: int8, name :: text
                     <span class="hljs-type">WHERE</span> gender = $<span class="hljs-number">1</span> :: text <span class="hljs-type">AND</span>
                           birthday &gt;= ($<span class="hljs-number">2</span> :: timestamptz) |]

<span class="hljs-type">Fold</span> (<span class="hljs-type">Int64</span>, <span class="hljs-type">Text</span>) result -&gt; <span class="hljs-type">Statement</span> (<span class="hljs-type">Text</span>, <span class="hljs-type">UTCTime</span>) result</code></pre>
<!-- 
The problems with typeclasses are why I'm also considering something seemingly crazy like this.

Obviously to get to your desired composite types, you can apply all kinds of mapping to such a function.

Also notice that this all is still a valid Postgres syntax!
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-41">
    <section class="slide-content">
      <pre><code class="lang-haskell"><span class="hljs-title">ghci</span>&gt; :t [statement| <span class="hljs-type">SELECT</span> id :: int8, name :: text?
                     <span class="hljs-type">WHERE</span> gender = $<span class="hljs-number">1</span> :: text <span class="hljs-type">AND</span>
                           birthday &gt;= ($<span class="hljs-number">2</span> :: timestamptz) |]

<span class="hljs-type">Fold</span> (<span class="hljs-type">Int64</span>, <span class="hljs-type">Maybe</span> <span class="hljs-type">Text</span>) result -&gt; <span class="hljs-type">Statement</span> (<span class="hljs-type">Text</span>, <span class="hljs-type">UTCTime</span>) result</code></pre>
<!-- 
However I've intentionally missed one problem in the previous slide: Nulls.

This is why, we'd have to step away from the standard syntax with these changes.
 -->
    </section>
  </div>
  <div class="slide hidden" id="slide-42">
    <section class="slide-content">
      <pre><code class="lang-haskell"><span class="hljs-type">Detect</span> syntax errors at compile-time!</code></pre>
<!-- 
Finally, either way, it's gonna be a Quasiquoter-based API, because thus I'll be able to bundle in parser-based test for the statement's syntax correctnes at the time of compilation.
 -->
    </section>
  </div>
  <div class="slide hidden author-slide" id="slide-43">
    <section class="slide-content">
      <div class="author">
  <h1 class="name">Nikita Volkov</h1>
    <h3 class="twitter">
      <a href="http://twitter.com/@NikitaYVolkov">@NikitaYVolkov</a>
    </h3>
    <h3 class="url">
      <a href="http://nikita-volkov.github.io">http://nikita-volkov.github.io</a>
    </h3>
</div>

    </section>
  </div>


  <script type="text/javascript">
    /**
 * Returns the current page number of the presentation.
 */
function currentPosition() {
  return parseInt(document.querySelector('.slide:not(.hidden)').id.slice(6));
}


/**
 * Navigates forward n pages
 * If n is negative, we will navigate in reverse
 */
function navigate(n) {
  var position = currentPosition();
  var numSlides = document.getElementsByClassName('slide').length;

  /* Positions are 1-indexed, so we need to add and subtract 1 */
  var nextPosition = (position - 1 + n) % numSlides + 1;

  /* Normalize nextPosition in-case of a negative modulo result */
  nextPosition = (nextPosition - 1 + numSlides) % numSlides + 1;

  document.getElementById('slide-' + position).classList.add('hidden');
  document.getElementById('slide-' + nextPosition).classList.remove('hidden');

  updateProgress();
  updateURL();
  updateTabIndex();
}


/**
 * Updates the current URL to include a hashtag of the current page number.
 */
function updateURL() {
  window.history.replaceState({} , null, '#' + currentPosition());
}


/**
 * Sets the progress indicator.
 */
function updateProgress() {
  var progressBar = document.querySelector('.progress-bar');

  if (progressBar !== null) {
    var numSlides = document.getElementsByClassName('slide').length;
    var position = currentPosition() - 1;
    var percent = (numSlides === 1) ? 100 : 100 * position / (numSlides - 1);
    progressBar.style.width = percent.toString() + '%';
  }
}


/**
 * Removes tabindex property from all links on the current slide, sets
 * tabindex = -1 for all links on other slides. Prevents slides from appearing
 * out of control.
 */
function updateTabIndex() {
  var allLinks = document.querySelectorAll('.slide a');
  var position = currentPosition();
  var currentPageLinks = document.getElementById('slide-' + position).querySelectorAll('a');
  var i;

  for (i = 0; i < allLinks.length; i++) {
    allLinks[i].setAttribute('tabindex', -1);
  }

  for (i = 0; i < currentPageLinks.length; i++) {
    currentPageLinks[i].removeAttribute('tabindex');
  }
}

/**
 * Determines whether or not we are currently in full screen mode
 */
function isFullScreen() {
  return document.fullscreenElement ||
         document.mozFullScreenElement ||
         document.webkitFullscreenElement ||
         document.msFullscreenElement;
}

/**
 * Toggle fullScreen mode on document element.
 * Works on chrome (>= 15), firefox (>= 9), ie (>= 11), opera(>= 12.1), safari (>= 5).
 */
function toggleFullScreen() {
  /* Convenient renames */
  var docElem = document.documentElement;
  var doc = document;

  docElem.requestFullscreen =
      docElem.requestFullscreen ||
      docElem.msRequestFullscreen ||
      docElem.mozRequestFullScreen ||
      docElem.webkitRequestFullscreen.bind(docElem, Element.ALLOW_KEYBOARD_INPUT);

  doc.exitFullscreen =
      doc.exitFullscreen ||
      doc.msExitFullscreen ||
      doc.mozCancelFullScreen ||
      doc.webkitExitFullscreen;

  isFullScreen() ? doc.exitFullscreen() : docElem.requestFullscreen();
}

document.addEventListener('DOMContentLoaded', function () {
  // Update the tabindex to prevent weird slide transitioning
  updateTabIndex();

  // If the location hash specifies a page number, go to it.
  var page = window.location.hash.slice(1);
  if (page) {
    navigate(parseInt(page) - 1);
  }

  document.onkeydown = function (e) {
    var kc = e.keyCode;

    // left, down, H, J, backspace, PgUp - BACK
    // up, right, K, L, space, PgDn - FORWARD
    // enter - FULLSCREEN
    if (kc === 37 || kc === 40 || kc === 8 || kc === 72 || kc === 74 || kc === 33) {
      navigate(-1);
    } else if (kc === 38 || kc === 39 || kc === 32 || kc === 75 || kc === 76 || kc === 34) {
      navigate(1);
    } else if (kc === 13) {
      toggleFullScreen();
    }
  };

  if (document.querySelector('.next') && document.querySelector('.prev')) {
    document.querySelector('.next').onclick = function (e) {
      e.preventDefault();
      navigate(1);
    };

    document.querySelector('.prev').onclick = function (e) {
      e.preventDefault();
      navigate(-1);
    };
  }
});
  </script>
</body>
</html>